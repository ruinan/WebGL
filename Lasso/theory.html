<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        canvas {
            background-color: black;
        }
    </style>
</head>

<body onload='main()'>
    <canvas id='canvas' width='640' height='480'></canvas>
    <script src="./gl-matrix.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>

    <script id="2d-vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;
        uniform vec2 u_resolution;
        void main() {
            vec2 zeroToOne = a_position.xy / u_resolution;
            vec2 zeroToTwo = zeroToOne * 2.0;
            vec2 clipSpace = zeroToTwo - 1.0; 
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        }
    </script>
    <!-- fragment shader -->
    <script id="2d-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec4 u_color;
        void main() {
            gl_FragColor = u_color;
        }
    </script>
    <script>
        function main() {
            const canvas = document.querySelector('#canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                console.error("get webgl context failed!");
                return;
            }
            const program = webglUtils.createProgramFromScripts(gl, ["2d-vertex-shader", "2d-fragment-shader"]);

            const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
            const colorUniformLocation = gl.getUniformLocation(program, "u_color");
            const resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
    


            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // 绑定position Buffer 到 gl.Array_Buffer

            // const position = [
            //     10, 20,
            //     80, 20,
            //     10, 30,
            //     10, 30,
            //     80, 20,
            //     80, 30,
            // ];

            // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(position), gl.STATIC_DRAW);

            webglUtils.resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);

            gl.enableVertexAttribArray(positionAttributeLocation);

            const size = 2;
            const type = gl.FLOAT;
            const normalize = false;
            const stride = 0;
            const offset = 0;

            gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

            
            for (let i = 0; i < 50; i++) {
                const primitiveType = gl.TRIANGLES;
                const offsetDraw = 0;
                // const count = position.length / 2;

                setRectangle(gl, randomInt(300), randomInt(300), randomInt(300), randomInt(300));
                gl.uniform4f(colorUniformLocation, Math.random(), Math.random(), Math.random(), 1, 1);

                gl.drawArrays(primitiveType, offsetDraw, 6);
            }


        }

        function randomInt(range) {
            return Math.floor(Math.random() * range);
        }

        // 用参数生成矩形顶点并写进缓冲

        function setRectangle(gl, x, y, width, height) {
            var x1 = x;
            var x2 = x + width;
            var y1 = y;
            var y2 = y + height;

            // 注意: gl.bufferData(gl.ARRAY_BUFFER, ...) 将会影响到
            // 当前绑定点`ARRAY_BUFFER`的绑定缓冲
            // 目前我们只有一个缓冲，如果我们有多个缓冲
            // 我们需要先将所需缓冲绑定到`ARRAY_BUFFER`

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2
            ]), gl.STATIC_DRAW);
        }
    </script>
</body>

</html>